; maestro
; License: GPLv2
; See LICENSE.txt for full license text
; Author: Sam Kravitz
;
; FILE: intr.s
; DATE: March 24th, 2022
; DESCRIPTION: Initializes and handles interrupts
;
; the comments below are mostly my notes because I
; had a pretty hard time wrapping my head around this stuff
;
; x86 provides 256 interrupts
; interrupts are divided into 2 classes: exceptions and irqs (hardware interrupts)
; exceptions are further divided into these classes:
;	- fault: correctable exceptions (e.x. page fault)
;	- trap: programmer initiated exception (e.x. int 80h)
;   - abort: severe, possibly unrecoverrable error
;
; interrupts 0-20h are exceptions that are generated by the cpu when an error occurs
; maestro refers to these interrupts as 'xint' (eXception INTterrupt)
; some exceptions cause the cpu to automatically push an error code on the stack
; for the exceptions that don't, a dummy error code will be pushed so the stack is consistent
;
; interrupts 20h-ffh are available for use as irqs or traps
; when the processor boots, irq0-irq7 are mapped to interrupt 8h-fh
; and irq8-irq15 are mapped to interrupt 70h-77h
; so, at boot time, irq0-irq7 overlap with the exceptions!
; this is a problem, but it is possible to re-map irqs.
; 
; maestro defines 16 irqs which will be mapped to interrupts 20h-2fh

[bits 32]

	global intr_init
	global set_vect
	global ivect

	extern io_wait

	section .text

; initialize and remap the pic
; initializing the pic involves sending 4 values to the pic, Initialization Control Words (icw)
; each icw specicifies certain behavior for the pic
; cdecl - void intr_init();
intr_init:
	; icw1
	; pic will expect icw4 (bit 0)
	; initialize the pic (bit 4)
	mov al, ICW1
	
	out PIC1_CMD, al ; send icw1 to primary pic
	call io_wait
	out PIC2_CMD, al ; send icw1 to secondary pic
	call io_wait

	; icw2 - remaps pic
	; primary pic controls irq0-irq7, which we want to map to interrupt 20h,
	; so we send 20h to primary pic
	; secondary pic controls irq8-irq15, which we want to map to interrupt 28h,
	; so we send 28h to secondary pic
	mov al, 0x20
	out PIC1_DATA, al
	call io_wait

	mov al, 0x28
	out PIC2_DATA, al
	call io_wait

	; icw3
	; the value we send to primary pic tells it which line the secondary pic is on
	; the secondary pic is on line 2, so send it 4 (0b100) (index 2 is set)
	; the value we send to the secondary pic tells it which line it is on
	; the secondary pic is on line 2, so send it 2 (confusing? yes)
	mov al, 4
	out PIC1_DATA, al
	call io_wait

	mov al, 2
	out PIC1_DATA, al
	call io_wait
	nop

	; icw4
	; the only bit to set here is bit 0 (80x86 mode)
	; send to both pics
	mov al, 1
	out PIC1_DATA, al
	call io_wait

	out PIC2_DATA, al
	call io_wait

	; unmask (enable) all interrupts
	mov al, 0x0
	out PIC1_DATA, al
	call io_wait

	out PIC2_DATA, al
	call io_wait

	ret

; define exceptions (interrupts 0 - 31)
; exceptions 8, 10, 11, 12, 13, 14, 17, 21, 29, & 30 push error codes
xint0:
	push 0
	push 0
	jmp isr
xint1:
	push 0
	push 1
	jmp isr
xint2:
	push 0
	push 2
	jmp isr
xint3:
	push 0
	push 3
	jmp isr
xint4:
	push 0
	push 4
	jmp isr
xint5:
	push 0
	push 5
	jmp isr
xint6:
	push 0
	push 6
	jmp isr
xint7:
	push 0
	push 7
	jmp isr
xint8:
	push 8
	jmp isr
xint9:
	push 0
	push 9
	jmp isr
xint10:
	push 10
	jmp isr
xint11:
	push 11
	jmp isr
xint12:
	push 12
	jmp isr
xint13:
	push 13
	jmp isr
xint14:
	push 14
	jmp isr
xint15:
	push 0
	push 15
	jmp isr
xint16:
	push 0
	push 16
	jmp isr
xint17:
	push 17
	jmp isr
xint18:
	push 0
	push 18
	jmp isr
xint19:
	push 0
	push 19
	jmp isr
xint20:
	push 0
	push 20
	jmp isr
xint21:
	push 21
	jmp isr
xint22:
	push 0
	push 22
	jmp isr
xint23:
	push 0
	push 23
	jmp isr
xint24:
	push 0
	push 24
	jmp isr
xint25:
	push 0
	push 25
	jmp isr
xint26:
	push 0
	push 26
	jmp isr
xint27:
	push 0
	push 27
	jmp isr
xint28:
	push 0
	push 28
	jmp isr
xint29:
	push 29
	jmp isr
xint30:
	push 30
	jmp isr
xint31:
	push 0
	push 31
	jmp isr

; define irqs (interrupts 32 - 47)
irq0:
	push 0
	push 32
	jmp isr
irq1:
	push 0
	push 33
	jmp isr
irq2:
	push 0
	push 34
	jmp isr
irq3:
	push 0
	push 35
	jmp isr
irq4:
	push 0
	push 36
	jmp isr
irq5:
	push 0
	push 37
	jmp isr
irq6:
	push 0
	push 38
	jmp isr
irq7:
	push 0
	push 39
	jmp isr
irq8:
	push 0
	push 40
	jmp isr
irq9:
	push 0
	push 41
	jmp isr
irq10:
	push 0
	push 42
	jmp isr
irq11:
	push 0
	push 43
	jmp isr
irq12:
	push 0
	push 44
	jmp isr
irq13:
	push 0
	push 45
	jmp isr
irq14:
	push 0
	push 46
	jmp isr
irq15:
	push 0
	push 47
	jmp isr

; this is the actual isr handler
; before jumping here, an error code (or dummy 0) and interrupt number were just pushed onto the stack
; handler will save the program state with pusha, so the stack will look like this:
;	error code
;	interrupt number
;	eax
;	ecx
;	edx
;	ebx
;	esp (original value)
;	ebp
;	esi
;	edi
;
; error code and interrupt number can be found at [esp + 32] and [esp + 36], respectively
isr:
	pusha                              ; save program state
	mov eax, [esp + 32]                ; eax = interrupt number
	and eax, 0xff                      ; only 256 interrupts, so zero all but bottom byte
	mov ecx, [user_handlers + 4 * eax] ; ecx = user handler
	push eax                           ; save interrupt number
	call ecx                           ; handler()
	pop ecx                            ; restore interrupt number

	; acknowledge interrupt if irq
	cmp cl, IRQ_BASE                   ; if (interrupt_number < irq0)
	jl .done
	cmp cl, IRQ_END                    ; if (interrupt_number > irq15)
	jg .done

	; send eoi to primary pic for all irq
	mov al, EOI
	out PIC1_CMD, al

	; for irq8-15, also send eoi to secondary pic
	sub cl, IRQ_BASE
	cmp cl, 8                          ; if (irq < irq8)
	jl .done

	out PIC2_CMD, al                   ; secondary pic eoi
	
	.done:
	add esp, 8                         ; restore stack from pushing error code & interrupt number 
	popa                               ; restore state
	iret

set_vect:
	mov esi, [esp + 4]                 ; esi = i
	mov ecx, [esp + 8]                 ; ecx = handler
	mov [user_handlers + 4 * esi], ecx ; user_handlers[i] = handler
	ret

	section .data
	align 4
ivect:
	dd xint0
	dd xint1
	dd xint2
	dd xint3
	dd xint4
	dd xint5
	dd xint6
	dd xint7
	dd xint8
	dd xint9
	dd xint10
	dd xint11
	dd xint12
	dd xint13
	dd xint14
	dd xint15
	dd xint16
	dd xint17
	dd xint18
	dd xint19
	dd xint20
	dd xint21
	dd xint22
	dd xint23
	dd xint24
	dd xint25
	dd xint26
	dd xint27
	dd xint28
	dd xint29
	dd xint30
	dd xint31
	dd irq0
	dd irq1
	dd irq2
	dd irq3
	dd irq4
	dd irq5
	dd irq6
	dd irq7
	dd irq8
	dd irq9
	dd irq10
	dd irq11
	dd irq12
	dd irq13
	dd irq14
	dd irq15

	section .bss
user_handlers:
	resd 256 

; constants
PIC1_CMD  equ 20h  ; primary pic command port
PIC1_DATA equ 21h  ; primary pic data port
PIC2_CMD  equ 0xa0 ; secondary pic command port
PIC2_DATA equ 0xa1 ; secondary pic data port

IRQ_BASE  equ 20h  ; first irq
IRQ_END   equ 2fh  ; last irq
EOI       equ 20h  ; value to send to pic to acknowledge interrupt
ICW1 equ 00010001b ; icw1 value to send to pic
