; maestro
; License: GPLv2
; See LICENSE.txt for full license text
; Author: Sam Kravitz
;
; FILE: intr.s
; DATE: March 24th, 2022
; DESCRIPTION: Initializes and handles interrupts
;
; the comments below are mostly my notes because I
; had a pretty hard time wrapping my head around this stuff
;
; x86 provides 256 interrupts
; interrupts are divided into 2 classes: exceptions and irqs (hardware interrupts)
; exceptions are further divided into these classes:
;	- fault: correctable exceptions (e.x. page fault)
;	- trap: programmer initiated exception (e.x. int 80h)
;	- abort: severe, possibly unrecoverrable error
;
; interrupts 0-20h are exceptions that are generated by the cpu when an error occurs
; maestro refers to these interrupts as 'xint' (eXception INTterrupt)
; some exceptions cause the cpu to automatically push an error code on the stack
; for the exceptions that don't, a dummy error code will be pushed so the stack is consistent
;
; interrupts 20h-ffh are available for use as irqs or traps
; when the processor boots, irq0-irq7 are mapped to interrupt 8h-fh
; and irq8-irq15 are mapped to interrupt 70h-77h
; so, at boot time, irq0-irq7 overlap with the exceptions!
; this is a problem, but it is possible to re-map irqs.
; 
; maestro defines 16 irqs which will be mapped to interrupts 20h-2fh

[bits 32]

	global intr_init
	global set_vect
	global ivect
	global user_handlers
	global disable
	global restore
	global isr_end
	global new_label


	extern io_wait
	extern isr
	extern kputs

	section .text

; initialize and remap the pic
; initializing the pic involves sending 4 values to the pic, Initialization Control Words (icw)
; each icw specicifies certain behavior for the pic
; cdecl - void intr_init();
intr_init:
	; send reset command to pic1 and pic2
	mov al, 11h
	out PIC1_CMD, al
	call io_wait
	mov al, 11h
	out PIC2_CMD, al
	call io_wait

	; icw1
	; pic will expect icw4 (bit 0)
	; initialize the pic (bit 4)
	mov al, ICW1
	
	out PIC1_CMD, al ; send icw1 to primary pic
	call io_wait
	out PIC2_CMD, al ; send icw1 to secondary pic
	call io_wait

	; icw2 - remaps pic
	; primary pic controls irq0-irq7, which we want to map to interrupt 32,
	; so we send 32 to primary pic
	; secondary pic controls irq8-irq15, which we want to map to interrupt 40,
	; so we send 40 to secondary pic
	mov al, 32
	out PIC1_DATA, al
	call io_wait

	mov al, 40
	out PIC2_DATA, al
	call io_wait

	; icw3
	; the value we send to primary pic tells it which line the secondary pic is on
	; the secondary pic is on line 2, so send it 4 (0b100) (index 2 is set)
	; the value we send to the secondary pic tells it which line it is on
	; the secondary pic is on line 2, so send it 2 (confusing? yes)
	mov al, 4
	out PIC1_DATA, al
	call io_wait
	mov al, 2
	out PIC2_DATA, al
	call io_wait

	; icw4
	; the only bit to set here is bit 0 (80x86 mode)
	; send to both pics
	mov al, 1
	out PIC1_DATA, al
	call io_wait
	mov al, 1
	out PIC2_DATA, al
	call io_wait

	; mask (disable) all irqs except for irq0 (timer), irq1 (keyboard)
	; and irq12 (mouse)
	; note - this needs to be changed when wanting to add other irqs
	mov al, 0xf8
	out PIC1_DATA, al
	call io_wait
	mov al, 0xef
	out PIC2_DATA, al
	call io_wait

	ret

; locally enable / disable interrupts

; cdecl - int disable()
; returns the current value of IF register in eflags
disable:
	pushf						; push flags on stack
	pop eax						; pop flags from stack into eax
	cli							; disable interrupts
	and eax, 202h				; clear all bits except IF flag (200h) and reserved flag (0x2)
	ret

; cdecl - void restore(int mask)
; pass the return value of disable() to this function
; to restore interrupts to the state they were in when disable() was called
restore:
	cli                         ; disable interrupts
	push ebp                    ; set up stack frame
	mov ebp, esp
	mov eax, [ebp + 8]          ; eax <- saved flags argument
	pushf                       ; push eflags on stack
	pop ecx                     ; pop flags into ecx
	or eax, ecx                 ; restore bits saved in disable() (200h and 0x2)
	push eax                    ; push eax (containing restored flags) onto stack
	popf                        ; pop restored flags
	pop ebp
	ret

; define exceptions (interrupts 0 - 31)
; exceptions 8, 10, 11, 12, 13, 14, 17, 21, 29, & 30 push error codes
xint0:
	push 0
	push 0
	jmp isr_bootstrap
xint1:
	push 0
	push 1
	jmp isr_bootstrap
xint2:
	push 0
	push 2
	jmp isr_bootstrap
xint3:
	push 0
	push 3
	jmp isr_bootstrap
xint4:
	push 0
	push 4
	jmp isr_bootstrap
xint5:
	push 0
	push 5
	jmp isr_bootstrap
xint6:
	push 0
	push 6
	jmp isr_bootstrap
xint7:
	push 0
	push 7
	jmp isr_bootstrap
xint8:
	push 8
	jmp isr_bootstrap
xint9:
	push 0
	push 9
	jmp isr_bootstrap
xint10:
	push 10
	jmp isr_bootstrap
xint11:
	push 11
	jmp isr_bootstrap
xint12:
	push 12
	jmp isr_bootstrap
xint13:
	push 13
	jmp isr_bootstrap
xint14:
	push 14
	jmp isr_bootstrap
xint15:
	push 0
	push 15
	jmp isr_bootstrap
xint16:
	push 0
	push 16
	jmp isr_bootstrap
xint17:
	push 17
	jmp isr_bootstrap
xint18:
	push 0
	push 18
	jmp isr_bootstrap
xint19:
	push 0
	push 19
	jmp isr_bootstrap
xint20:
	push 0
	push 20
	jmp isr_bootstrap
xint21:
	push 21
	jmp isr_bootstrap
xint22:
	push 0
	push 22
	jmp isr_bootstrap
xint23:
	push 0
	push 23
	jmp isr_bootstrap
xint24:
	push 0
	push 24
	jmp isr_bootstrap
xint25:
	push 0
	push 25
	jmp isr_bootstrap
xint26:
	push 0
	push 26
	jmp isr_bootstrap
xint27:
	push 0
	push 27
	jmp isr_bootstrap
xint28:
	push 0
	push 28
	jmp isr_bootstrap
xint29:
	push 29
	jmp isr_bootstrap
xint30:
	push 30
	jmp isr_bootstrap
xint31:
	push 0
	push 31
	jmp isr_bootstrap

; define irqs (interrupts 32 - 47)
irq0:
	push 0
	push 32
	jmp isr_bootstrap
irq1:
	push 0
	push 33
	jmp isr_bootstrap
irq2:
	push 0
	push 34
	jmp isr_bootstrap
irq3:
	push 0
	push 35
	jmp isr_bootstrap
irq4:
	push 0
	push 36
	jmp isr_bootstrap
irq5:
	push 0
	push 37
	jmp isr_bootstrap
irq6:
	push 0
	push 38
	jmp isr_bootstrap
irq7:
	push 0
	push 39
	jmp isr_bootstrap
irq8:
	push 0
	push 40
	jmp isr_bootstrap
irq9:
	push 0
	push 41
	jmp isr_bootstrap
irq10:
	push 0
	push 42
	jmp isr_bootstrap
irq11:
	push 0
	push 43
	jmp isr_bootstrap
irq12:
	push 0
	push 44
	jmp isr_bootstrap
irq13:
	push 0
	push 45
	jmp isr_bootstrap
irq14:
	push 0
	push 46
	jmp isr_bootstrap
irq15:
	push 0
	push 47
	jmp isr_bootstrap
sysc:
	push 0
	push 48
	jmp isr_bootstrap

; bootstrap the C isr handler
; before jumping here, an error code (or dummy 0) and interrupt number were just pushed onto the stack
; handler will save the program state with pusha, so the stack will look like this:
;	error code
;	interrupt number
;	eax
;	ecx
;	edx
;	ebx
;	esp (original value)
;	ebp
;	esi
;	edi;
isr_bootstrap:
	pusha                              ; save registers

	push ds                            ; save segment registers
	push es
	push fs
	push gs

	push esp
	call isr

isr_end:
	add esp, 4                         ; restore stack state

new_label:
	pop gs                             ; restore segment registers
	pop fs
	pop es
	pop ds
	popa                               ; restore saved registers

	add esp, 8                         ; restore stack from pushing error code & interrupt number
	iret

set_vect:
	mov esi, [esp + 4]                 ; esi = i
	mov ecx, [esp + 8]                 ; ecx = handler
	mov [user_handlers + 4 * esi], ecx ; user_handlers[i] = handler
	ret

	section .data
	align 4
ivect:
	dd xint0
	dd xint1
	dd xint2
	dd xint3
	dd xint4
	dd xint5
	dd xint6
	dd xint7
	dd xint8
	dd xint9
	dd xint10
	dd xint11
	dd xint12
	dd xint13
	dd xint14
	dd xint15
	dd xint16
	dd xint17
	dd xint18
	dd xint19
	dd xint20
	dd xint21
	dd xint22
	dd xint23
	dd xint24
	dd xint25
	dd xint26
	dd xint27
	dd xint28
	dd xint29
	dd xint30
	dd xint31
	dd irq0
	dd irq1
	dd irq2
	dd irq3
	dd irq4
	dd irq5
	dd irq6
	dd irq7
	dd irq8
	dd irq9
	dd irq10
	dd irq11
	dd irq12
	dd irq13
	dd irq14
	dd irq15
	dd sysc

mystr:
	db 'hello world', 0

	section .bss
user_handlers:
	resd 256 

; constants
PIC1_CMD  equ 20h  ; primary pic command port
PIC1_DATA equ 21h  ; primary pic data port
PIC2_CMD  equ 0xa0 ; secondary pic command port
PIC2_DATA equ 0xa1 ; secondary pic data port

ICW1 equ 00010001b ; icw1 value to send to pic
